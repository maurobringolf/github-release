#!/bin/bash

--VERSION() {
  echo "github-release v1.1.0"
}

GENERATE_POST_BODY() {
  cat <<EOF
{
  "tag_name": "$NEXT_RELEASE",
  "target_commitish": "master",
  "name": "$NEXT_RELEASE",
  "body": $FORMAT_CONTENT,
  "draft": true,
  "prerelease": false
}
EOF
}

CAPITALIZE() {
  first_capital="$(echo "$1"|cut -c1|tr '[:lower:]' '[:upper:]' )"
  rest_regular="$(echo "$1"|cut -c2-)"
  echo "$first_capital$rest_regular"
}

HORIZONTAL_LINE() {
  printf '%*s\n' "${COLUMNS:-$(tput cols)}" '' | tr ' ' -
}

CREATE_CHANGELOG() {

  # Definition of default commit types
  COMMIT_TYPES=( breaking bugfix feature frontend backend workflow testing documentation internal )

  # String to accumulate changelog
  CONTENT=""

  # Get all commits with type annotations and make them paragraphs.
  for TYPE in "${COMMIT_TYPES[@]}"
    do
      if [ -z "$1" ]
        then
          PARAGRAPH="$(git log --format="* %s (%h)" --grep="^\[${TYPE}\]")"
        else
          PARAGRAPH="$(git log "$1"..HEAD --format="* %s (%h)" --grep="^\[${TYPE}\]")"
      fi
      if [ ! -z "$PARAGRAPH" ]
        then
          TITLE="$(CAPITALIZE "$TYPE")"
          PARAGRAPH="${PARAGRAPH//\[$TYPE\] /}"
          CONTENT="$CONTENT## $TITLE\n\n$PARAGRAPH\n\n"
      fi
    done

  # Regex used to find commits without types
  TYPES_REGEX=""
  for TYPE in "${COMMIT_TYPES[@]}"
    do
      TYPES_REGEX="$TYPES_REGEX\[$TYPE\]\|"
  done
  TYPES_REGEX="$TYPES_REGEX\[skip-changelog\]"

  # Get all commit without type annotation and make them another paragraph.
  if [ -z "$1" ]
    then
      PARAGRAPH="$(git log --format=";* %s (%h);")"
    else
      PARAGRAPH="$(git log "$1"..HEAD --format=";* %s (%h);")"
  fi
  OIFS="$IFS"
  IFS=";"
  FILTERED_PARAGRAPH=""
  for COMMIT in $PARAGRAPH
   do
     TRIMMED_COMMIT="$(echo "$COMMIT" | xargs)"
    if [ ! -z "$TRIMMED_COMMIT" ] && ! echo "$TRIMMED_COMMIT" | grep -q "$TYPES_REGEX"
      then
        FILTERED_PARAGRAPH="$FILTERED_PARAGRAPH$TRIMMED_COMMIT\n"
    fi
  done
  IFS="$OIFS"

  # Only add to content if there are commits without type annotations.
  if [ ! -z "$FILTERED_PARAGRAPH" ]
   then
     CONTENT="$CONTENT## Other\n\n$FILTERED_PARAGRAPH\n\n"
  fi

  # Output changelog
  echo -e "$CONTENT"
}

#
# Main script
#

if [ "$1" == "--version" ]
  then
    --VERSION
    exit 0
fi


echo -e "|===> GitHub Release <===|\n\n"

# Exit if not in a Git repository.
if [ "true" != "$(git rev-parse --is-inside-work-tree 2> /dev/null)" ]
  then
    echo -e "This does not seem to be a Git repository.\n"
    exit
fi

while getopts ":p" OPTION
  do
    case $OPTION in
      p)
        PREVIEW=true
        ;;
      \?)
        echo "Invalid option: -$OPTARG"
        exit
        ;;
    esac
done

REPOSITORY=$(git config --get remote.origin.url | sed -E 's/https?:\/\/(www.)?github.com\/|git@github.com:([A-Za-z]+\/[A-Za-z]+)/\2/')

if [ -z "$(git tag)" ]
  then
    CONTENT=$(CREATE_CHANGELOG)
  else
    LATEST_RELEASE="$(git describe --tags --abbrev=0)"
    CONTENT=$(CREATE_CHANGELOG "${LATEST_RELEASE}")
fi

if [ "$PREVIEW" = true ]
  then
    HORIZONTAL_LINE
    echo "$CONTENT"
    HORIZONTAL_LINE
    exit
fi

echo -e "This tool will draft a new release to ${REPOSITORY}."

if [ -z "$(git tag)" ]
  then
    echo -e "This seems to be its first release. Congratulations!"
  else
    echo -e "Its latest release is ${LATEST_RELEASE}.\n\n"
fi

echo -e "What version would you like to release?\n-- "

read -r NEXT_RELEASE

FORMAT_CONTENT=$(node -p -e 'JSON.stringify(process.argv[1])' "${CONTENT}")

RELEASE=$(curl --silent -H "Content-Type: application/json" -X POST --data "$(GENERATE_POST_BODY)" "https://api.github.com/repos/${REPOSITORY}/releases?access_token=${AUTOMATIC_RELEASE_GITHUB_TOKEN}")

EDIT_URL="$(node -p -e 'JSON.parse(process.argv[1]).html_url.replace('/\\/tag\\//', '/edit/')' "${RELEASE}")"

open "$EDIT_URL"
